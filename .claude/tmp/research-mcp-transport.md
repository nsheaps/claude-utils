# MCP Transport Layer Research — 2026

**Research Date**: 2026-02-16  
**Protocol Version**: 2025-11-25 (latest official)  
**Specification Source**: [modelcontextprotocol.io/specification/2025-11-25](https://modelcontextprotocol.io/specification/2025-11-25)

---

## Executive Summary

The Model Context Protocol (MCP) defines a **transport-agnostic** architecture with officially supported transports for stdio and Streamable HTTP. The protocol uses JSON-RPC 2.0 for all messages and explicitly allows custom transport implementations. For mesh MCP server architectures, understanding transport layer capabilities is critical for choosing between WebRTC data channels and Socket.io as the underlying communication channel.

**Key Takeaway**: MCP is transport-agnostic. Any bidirectional communication channel that supports UTF-8 JSON-RPC 2.0 message exchange can be used as a custom transport. Both WebRTC data channels and Socket.io are viable, with WebSocket showing active community interest and emerging SEP (Spec Enhancement Proposal) support.

---

## 1. Officially Supported Transport Types

As of protocol version 2025-11-25, MCP defines **two standard transport mechanisms**:

### 1.1 STDIO Transport

**Purpose**: Local, process-to-process communication  
**Ideal For**: Local integrations, command-line tools, embedded systems

**Mechanics**:
- Client launches MCP server as a subprocess
- Server reads from `stdin`, writes to `stdout`
- Messages are individual JSON-RPC 2.0 objects delimited by newlines
- Messages **MUST NOT** contain embedded newlines
- Optional logging to `stderr` (client may ignore or forward)

**Constraints**:
- Single client per server instance
- No network overhead
- Lowest latency option
- Simple synchronous message exchange

### 1.2 Streamable HTTP Transport

**Purpose**: Remote, multi-client server communication  
**Ideal For**: Cloud deployments, load-balanced services, web-based applications

**Added**: Protocol version 2025-03-26 (replaces deprecated HTTP+SSE from 2024-11-05)

---

## 2. MCP Streamable HTTP — Technical Deep Dive

### 2.1 Core Architecture

- Server provides single HTTP endpoint supporting both POST and GET
- Client sends requests via HTTP POST
- Server responds with either single response or SSE stream
- Client can open SSE stream via HTTP GET to receive server-initiated messages

### 2.2 Session Management (Critical for Mesh)

**Stateful Sessions** allow servers to maintain connection state across client reconnections.

#### Session Initialization
```
POST /mcp
{"jsonrpc": "2.0", "id": 1, "method": "initialize", ...}

← HTTP 200 OK
← MCP-Session-Id: eyJjbGllbnRJZCI6IjEyMyJ9...
← {"jsonrpc": "2.0", "id": 1, "result": {...}}
```

#### Subsequent Requests (with Session)
```
POST /mcp
MCP-Session-Id: eyJjbGllbnRJZCI6IjEyMyJ9...
MCP-Protocol-Version: 2025-11-25
{"jsonrpc": "2.0", "id": 2, "method": "tools/list"}
```

#### Session Termination
- Server may timeout sessions (respond with HTTP 404)
- Client may delete session via HTTP DELETE
- Client re-initializes without session ID on 404

#### Session ID Properties
- Generated by server at initialization time
- Must be globally unique and cryptographically secure
- Must be visible ASCII characters only (0x21 to 0x7E)
- Must be handled securely by client

### 2.3 Request/Response Patterns

#### Single-Response Pattern
```
POST /mcp
Accept: application/json, text/event-stream

← HTTP 200 OK
← Content-Type: application/json
← {"jsonrpc": "2.0", "id": 1, "result": {...}}
```

#### Streaming-Response Pattern (With SSE)
```
POST /mcp
Accept: application/json, text/event-stream

← HTTP 200 OK
← Content-Type: text/event-stream
← id: evt-123
← data: <empty>
←
← id: evt-124
← data: {"jsonrpc": "2.0", "method": "notifications/progress", ...}
←
← id: evt-125
← data: {"jsonrpc": "2.0", "id": 1, "result": {...}}
```

### 2.4 Resumability and Redelivery

For fault-tolerant, long-lived streams:

1. Server assigns event IDs to SSE events
2. Client resumes with Last-Event-ID header
3. Event IDs tracked per-stream, allowing independent cursors

---

## 3. JSON-RPC 2.0 Message Format (Over Any Transport)

All MCP messages follow JSON-RPC 2.0 specification, regardless of transport.

### 3.1 Request
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "weather",
    "arguments": { "location": "San Francisco" }
  }
}
```

- `jsonrpc`: Always "2.0"
- `id`: Integer or string (MUST NOT be null), unique within session
- `method`: RPC method name
- `params`: Object or array (optional)

### 3.2 Response (Success)
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [{ "type": "text", "text": "68°F" }]
  }
}
```

### 3.3 Response (Error)
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Method not found",
    "data": { "reason": "Unknown method" }
  }
}
```

### 3.4 Notification (No Response)
```json
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

No `id` field; server does not send response.

---

## 4. MCP Sampling — Server-Initiated LLM Requests

**Key Feature**: Allows MCP servers to request LLM completions from the client's AI system without embedding LLM SDKs.

### 4.1 How It Works

```
MCP Server
    │
    ├─ "I need model help to decide X"
    │
    ├─→ sampling/createMessage
    │
    MCP Client
        │
        ├─ Review & get user approval
        │
        ├─ Forward to connected LLM
        │
    ← Return completion result
    │
    ├─ Server uses result to continue execution
```

### 4.2 Request Format

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": { "type": "text", "text": "Analyze this data: ..." }
      }
    ],
    "modelPreferences": {
      "hints": ["claude-3-5-sonnet", "gpt-4-turbo"],
      "intelligencePriority": 0.8,
      "speedPriority": 0.5
    },
    "systemPrompt": "You are a data analyst.",
    "maxTokens": 500
  }
}
```

### 4.3 Security & Control

- **Client retains LLM access control**: User/host must approve each sampling request
- **User visibility**: Clients show sampling requests to users before forwarding
- **Hint-based model selection**: Server suggests (hints), client makes final choice
- **No server model API keys**: Server doesn't need direct LLM credentials

**Critical for Mesh**: Enables recursive LLM interactions in server-to-server communication without embedding LLM clients.

---

## 5. Custom Transport Implementations

### 5.1 Official Guidance

From MCP specification (2025-11-25):

> "Clients and servers **MAY** implement additional custom transport mechanisms to suit their specific needs. The protocol is transport-agnostic and can be implemented over any communication channel that supports bidirectional message exchange."

**Requirements**:
1. Preserve JSON-RPC 2.0 message format
2. Support lifecycle requirements (initialize → initialized → operations)
3. Document connection establishment and message patterns
4. Implement session management if stateful

### 5.2 WebSocket Transport (Proposed SEP-1287)

**Status**: Under discussion for 2026 Q2 specification release

**Key Features**:
- Bidirectional, full-duplex communication
- Long-lived connections (ideal for server-initiated notifications)
- Session support for state persistence
- Authentication via WebSocket subprotocols
- Protocol version negotiation

**Message Format** (WebSocket text frames only):
```
Client → Server:
{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}

Server → Client:
{"jsonrpc": "2.0", "id": 1, "result": {"tools": [...]}}

Server → Client (unsolicited notification):
{"jsonrpc": "2.0", "method": "notifications/resources/list_changed"}
```

**Session Resumption**:
```
ws://mcp-server/mcp?sessionId=abc123&version=2025-11-25

Client reconnects with previous session ID
```

**Authentication**:
```
Sec-WebSocket-Protocol: mcp.auth.bearer_token_xyz, mcp.version.2025-11-25

Server selects protocol from client's list
```

### 5.3 WebRTC Data Channels (Viable, Not Yet Adopted)

**Viability**: High (supports all JSON-RPC requirements)

**Advantages**:
- Peer-to-peer communication (no central server required)
- DTLS-secured automatically
- Low-latency, high-throughput
- NAT traversal via STUN/TURN
- Bidirectional, full-duplex

**Challenges**:
- Requires STUN/TURN infrastructure for NAT
- Connection setup more complex than HTTP/WebSocket
- Not standardized in MCP ecosystem yet
- Session management semantics need definition

**Use Cases for Mesh**:
- Direct peer-to-peer agent communication
- Encrypted by default (DTLS)
- Ideal for distributed mesh topologies

**Current Status**: No official MCP specification; custom transport implementation required.

### 5.4 Socket.io (Viable, Not Official)

**Viability**: High (JSON-RPC-compatible)

**Advantages**:
- Fallback from WebSocket to polling
- Built-in reconnection and session management
- Mature ecosystem, widely deployed

**Challenges**:
- Not part of official MCP specification
- Adds protocol layer overhead
- May add latency vs. native WebSocket
- Requires custom transport adapter

---

## 6. Server-to-Server Communication Patterns

### 6.1 Traditional MCP (Client-Server Only)

```
LLM Host / AI Application
    │
    ├─ MCP Client 1 ←→ MCP Server A (Resources)
    ├─ MCP Client 2 ←→ MCP Server B (Tools)
    ├─ MCP Client 3 ←→ MCP Server C (Prompts)
    └─ MCP Client 4 ←→ MCP Server C (Tools)
```

Servers don't directly communicate in standard MCP.

### 6.2 Mesh Architecture (Server-to-Server)

For agent orchestration where servers need to call each other:

```
MCP Server A (Orchestrator)
  - Exposes tools/resources
  - ALSO acts as MCP client
    connecting to Server B
         ↓
    MCP Client connection
    (Streamable HTTP or custom)
         ↓
MCP Server B (Specialized Worker)
  - Exposes tools
```

**Flow**:
1. LLM host requests service from Server A
2. Server A samples LLM for decision logic
3. Server A calls tools on Server B
4. Server A aggregates results
5. Server A returns to LLM host

### 6.3 Mesh with Sampling

Servers can use sampling to involve LLM in inter-server communication:

```
Server A
    │
    ├─ "Should I use Server B or Server C?"
    │
    └─→ sampling/createMessage
        (requests LLM completion)
```

### 6.4 Known Limitations

- **No native server-to-server protocol**: MCP doesn't define server-to-server; servers must implement client functionality
- **Sampling goes through host**: All LLM interactions route through host
- **Session state per connection**: Each server connection independent

---

## 7. Transport Comparison for Mesh

| Aspect | Stdio | Streamable HTTP | WebSocket | WebRTC | Socket.io |
|--------|-------|-----------------|-----------|--------|-----------|
| **Multi-client** | ✗ | ✓ | ✓ | ✓ (peer) | ✓ |
| **Bidirectional** | ✓ | ✓ | ✓ | ✓ | ✓ |
| **Server → Client** | Limited | ✓ (SSE) | ✓ | ✓ | ✓ |
| **Session State** | N/A | ✓ | ✓ | N/A | ✓ |
| **Streaming/Async** | ✓ | ✓ (SSE) | ✓ | ✓ | ~ |
| **Official Support** | ✓ | ✓ | Proposed | Custom | Custom |
| **Deployment Ease** | Simple | HTTP easy | WebSocket easy | Complex | Easy |
| **Latency** | Lowest | Low | Very low | Low (P2P) | Medium |
| **Firewall/NAT** | N/A | HTTP standard | Standard | STUN needed | Standard |
| **Scalability** | Single agent | Highly scalable | Highly scalable | Peer-limited | Scalable |

---

## 8. Recommendations for Mesh Agents

### Scenario 1: Agent Orchestrator Calling Specialized Agents (Same Datacenter)
→ **Streamable HTTP (stateful sessions)** + SSE
- Predictable latency
- Session state maintains agent context
- Easy debugging
- Proven in production

### Scenario 2: Real-Time Bidirectional Agent Communication
→ **WebSocket (when SEP-1287 ratified)** or **custom WebSocket transport**
- Lower latency than HTTP polling
- True server-to-server push capability
- Ideal for streaming results
- Future-proofed for 2026 Q2 MCP spec

### Scenario 3: Peer-to-Peer Agent Mesh (No Central Coordinator)
→ **WebRTC Data Channels** with custom transport
- Each agent is both client and server
- Direct peer-to-peer encrypted channels
- No single point of failure
- High complexity

### Scenario 4: Maximize Compatibility and Stability
→ **Streamable HTTP (stateless variant)**
- Load-balance across unlimited server instances
- Simplest operational model
- All messages independent
- Standard HTTP infrastructure

---

## 9. Security Considerations

### 9.1 Transport-Level Security

| Transport | Security | Notes |
|-----------|----------|-------|
| **Stdio** | Process-based | Inherit OS process security |
| **Streamable HTTP** | HTTPS | Use TLS for all remote deployments |
| **WebSocket** | WSS | Always use WSS (TLS-wrapped) |
| **WebRTC** | DTLS | Automatic encryption |

### 9.2 Session Hijacking Mitigation

1. **Session ID entropy**: ≥128 bits, cryptographically secure
2. **HTTPS/TLS mandatory**: Prevent session ID interception
3. **Short expiration**: Limit session lifetime
4. **IP binding** (optional): Restrict to originating IP
5. **Rate limiting**: Prevent brute-force guessing

### 9.3 Message-Level Security

1. All messages validated as JSON-RPC 2.0
2. Method authorization checked before operations
3. Input validation per schema
4. Error sanitization

---

## 10. Implementation Roadmap

### 2025 (Current)
- ✓ Streamable HTTP (stable, proven)
- ✓ Custom transport extensibility
- ✓ Session management best practices emerging
- ⚠ WebSocket SEP-1287 under discussion

### 2026 Q1
- Expected: SEP finalization
- Target: Spec release June 2026

### 2026 Q2+
- Likely: WebSocket transport becomes official
- Likely: Session management improvements
- Possible: Additional transport optimizations

---

## 11. References & Sources

### Official MCP Specification
- [MCP Specification 2025-11-25](https://modelcontextprotocol.io/specification/2025-11-25)
- [Transports](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- [Architecture Overview](https://modelcontextprotocol.io/docs/learn/architecture)

### Sampling
- [Sampling Specification 2025-03-26](https://spec.modelcontextprotocol.io/specification/2025-03-26/client/sampling/)

### Custom Transports & Community
- [SEP-1287: WebSocket Transport for MCP](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/1287)
- [nchan-mcp-transport: WebSocket/SSE transport](https://github.com/ConechoAI/nchan-mcp-transport)
- [websocket_mcp: Custom WebSocket implementation](https://github.com/zeropointo/websocket_mcp)

### Future & Evolution
- [Exploring the Future of MCP Transports — MCP Blog](http://blog.modelcontextprotocol.io/posts/2025-12-19-mcp-transport-future/)
- [Why MCP Deprecated SSE for Streamable HTTP — fka.dev](https://blog.fka.dev/blog/2025-06-06-why-mcp-deprecated-sse-and-go-with-streamable-http/)

### WebRTC Data Channels
- [Using WebRTC Data Channels — MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_data_channels)
- [RFC 8831: WebRTC Data Channel](https://www.rfc-editor.org/rfc/rfc8831.xml)

---

**Document Version**: 1.0  
**Last Updated**: 2026-02-16  
**For**: Mesh MCP Server Architecture Planning
