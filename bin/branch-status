#!/usr/bin/env bash
# branch-status - Display rich status for git branches
# Usage: branch-status [OPTIONS] <branch>
#
# Options:
#   --emoji           Output status as emoji string (default)
#   --json            Output status as JSON
#   -h, --help        Show this help message
#
# Status Indicators (emoji mode):
#   Remote: üü¢ = exists, ‚ùå = no
#   PR:     üü¢ = open, üîò = draft, ‚ùì = none
#   CI:     ‚ùå = fail, üü° = running, üü¢ = pass, ‚ùì = no CI
#   Review: üîò = none, üîµ = pending, üü° = comments, üî¥ = rejected, üü¢ = approved, ‚úÖ = satisfied
#   Merge:  ‚úÖ = ready, ‚ùå = conflicts, ‚ö†Ô∏è = outdated, üü¢ = clean

set -euo pipefail

OUTPUT_MODE="emoji"
BRANCH=""

show_help() {
  sed -n '2,14p' "$0" | sed 's/^# //' | sed 's/^#//'
  exit 0
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --emoji)  OUTPUT_MODE="emoji"; shift ;;
    --json)   OUTPUT_MODE="json"; shift ;;
    -h|--help) show_help ;;
    -*) echo "Unknown option: $1" >&2; show_help ;;
    *) BRANCH="$1"; shift ;;
  esac
done

if [[ -z "$BRANCH" ]]; then
  echo "Error: Branch name required" >&2
  show_help
fi

# Check for required tools
check_tool() {
  if ! command -v "$1" &>/dev/null; then
    echo "Error: $1 is required but not installed" >&2
    exit 1
  fi
}

check_tool gh
check_tool jq
check_tool git

# Get current repo info
REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || echo "")
if [[ -z "$REPO" ]]; then
  echo "Error: Not in a GitHub repository" >&2
  exit 1
fi

OWNER=$(echo "$REPO" | cut -d'/' -f1)
REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

# Check if branch exists on remote
REMOTE_EXISTS="false"
if git ls-remote --heads origin "$BRANCH" 2>/dev/null | grep -q .; then
  REMOTE_EXISTS="true"
fi

# Initialize status variables
PR_STATUS="none"
PR_NUMBER=""
CI_STATUS="none"
REVIEW_STATUS="none"
MERGEABLE="clean"

# Query GitHub for PR status if branch exists on remote
if [[ "$REMOTE_EXISTS" == "true" ]]; then
  # Use GraphQL to get all info in one query
  QUERY='
  query($owner: String!, $repo: String!, $branch: String!) {
    repository(owner: $owner, name: $repo) {
      pullRequests(headRefName: $branch, states: [OPEN], first: 1) {
        nodes {
          number
          isDraft
          mergeable
          mergeStateStatus
          reviewDecision
          commits(last: 1) {
            nodes {
              commit {
                statusCheckRollup {
                  state
                  contexts(first: 100) {
                    nodes {
                      ... on CheckRun {
                        conclusion
                        status
                      }
                      ... on StatusContext {
                        state
                      }
                    }
                  }
                }
              }
            }
          }
          reviews(first: 100) {
            nodes {
              state
            }
          }
          reviewRequests(first: 10) {
            totalCount
          }
        }
      }
    }
  }'

  GH_RESPONSE=$(gh api graphql -f query="$QUERY" \
    -f owner="$OWNER" \
    -f repo="$REPO_NAME" \
    -f branch="$BRANCH" 2>/dev/null || echo "{}")

  PR_DATA=$(echo "$GH_RESPONSE" | jq -r '.data.repository.pullRequests.nodes[0] // empty')

  if [[ -n "$PR_DATA" ]]; then
    IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft')
    PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')

    if [[ "$IS_DRAFT" == "true" ]]; then
      PR_STATUS="draft"
    else
      PR_STATUS="open"
    fi

    # CI Status - evaluate in order: fail > running > pass > none
    ROLLUP_STATE=$(echo "$PR_DATA" | jq -r '.commits.nodes[0].commit.statusCheckRollup.state // "NONE"')
    CONTEXTS=$(echo "$PR_DATA" | jq -r '.commits.nodes[0].commit.statusCheckRollup.contexts.nodes // []')

    HAS_FAILURE="false"
    HAS_PENDING="false"
    HAS_SUCCESS="false"

    # Check individual check runs and status contexts
    while IFS= read -r context; do
      CONCLUSION=$(echo "$context" | jq -r '.conclusion // empty')
      STATUS=$(echo "$context" | jq -r '.status // empty')
      STATE=$(echo "$context" | jq -r '.state // empty')

      # Check run
      if [[ -n "$CONCLUSION" ]]; then
        case "$CONCLUSION" in
          FAILURE|TIMED_OUT|CANCELLED|ACTION_REQUIRED) HAS_FAILURE="true" ;;
          SUCCESS) HAS_SUCCESS="true" ;;
        esac
      fi
      if [[ -n "$STATUS" ]] && [[ "$STATUS" != "COMPLETED" ]]; then
        HAS_PENDING="true"
      fi

      # Status context
      if [[ -n "$STATE" ]]; then
        case "$STATE" in
          FAILURE|ERROR) HAS_FAILURE="true" ;;
          PENDING) HAS_PENDING="true" ;;
          SUCCESS) HAS_SUCCESS="true" ;;
        esac
      fi
    done < <(echo "$CONTEXTS" | jq -c '.[]' 2>/dev/null || echo "")

    # Evaluate CI status in priority order
    if [[ "$HAS_FAILURE" == "true" ]]; then
      CI_STATUS="fail"
    elif [[ "$HAS_PENDING" == "true" ]]; then
      CI_STATUS="running"
    elif [[ "$HAS_SUCCESS" == "true" ]]; then
      CI_STATUS="pass"
    else
      CI_STATUS="none"
    fi

    # Review Status
    REVIEW_DECISION=$(echo "$PR_DATA" | jq -r '.reviewDecision // "NONE"')
    REVIEW_REQUESTS=$(echo "$PR_DATA" | jq -r '.reviewRequests.totalCount // 0')
    REVIEWS=$(echo "$PR_DATA" | jq -r '.reviews.nodes // []')

    HAS_APPROVAL="false"
    HAS_REJECTION="false"
    HAS_COMMENTS="false"

    while IFS= read -r review; do
      STATE=$(echo "$review" | jq -r '.state')
      case "$STATE" in
        APPROVED) HAS_APPROVAL="true" ;;
        CHANGES_REQUESTED) HAS_REJECTION="true" ;;
        COMMENTED) HAS_COMMENTS="true" ;;
      esac
    done < <(echo "$REVIEWS" | jq -c '.[]' 2>/dev/null || echo "")

    if [[ "$REVIEW_DECISION" == "APPROVED" ]]; then
      REVIEW_STATUS="satisfied"
    elif [[ "$HAS_REJECTION" == "true" ]]; then
      REVIEW_STATUS="rejected"
    elif [[ "$HAS_APPROVAL" == "true" ]]; then
      REVIEW_STATUS="approved"
    elif [[ "$HAS_COMMENTS" == "true" ]]; then
      REVIEW_STATUS="comments"
    elif [[ "$REVIEW_REQUESTS" -gt 0 ]]; then
      REVIEW_STATUS="pending"
    else
      REVIEW_STATUS="none"
    fi

    # Mergeable Status
    MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeable // "UNKNOWN"')
    MERGE_STATUS=$(echo "$PR_DATA" | jq -r '.mergeStateStatus // "UNKNOWN"')

    case "$MERGE_STATE" in
      CONFLICTING) MERGEABLE="conflicts" ;;
      MERGEABLE)
        case "$MERGE_STATUS" in
          CLEAN) MERGEABLE="ready" ;;
          BEHIND) MERGEABLE="outdated" ;;
          BLOCKED) MERGEABLE="clean" ;; # Blocked by branch protection but no conflicts
          *) MERGEABLE="clean" ;;
        esac
        ;;
      *) MERGEABLE="clean" ;;
    esac
  fi
fi

# Output based on mode
if [[ "$OUTPUT_MODE" == "json" ]]; then
  jq -n \
    --arg branch "$BRANCH" \
    --argjson remote_exists "$REMOTE_EXISTS" \
    --arg pr_status "$PR_STATUS" \
    --arg pr_number "$PR_NUMBER" \
    --arg ci_status "$CI_STATUS" \
    --arg review_status "$REVIEW_STATUS" \
    --arg mergeable "$MERGEABLE" \
    '{
      branch: $branch,
      remote_exists: $remote_exists,
      pr_status: $pr_status,
      pr_number: (if $pr_number == "" then null else ($pr_number | tonumber) end),
      ci_status: $ci_status,
      review_status: $review_status,
      mergeable: $mergeable
    }'
else
  # Emoji output
  EMOJI=""

  # Remote
  if [[ "$REMOTE_EXISTS" == "true" ]]; then
    EMOJI+="üü¢"
  else
    EMOJI+="‚ùå"
  fi

  # PR
  case "$PR_STATUS" in
    open) EMOJI+="üü¢" ;;
    draft) EMOJI+="üîò" ;;
    *) EMOJI+="‚ùì" ;;
  esac

  # CI
  case "$CI_STATUS" in
    fail) EMOJI+="‚ùå" ;;
    running) EMOJI+="üü°" ;;
    pass) EMOJI+="üü¢" ;;
    *) EMOJI+="‚ùì" ;;
  esac

  # Review
  case "$REVIEW_STATUS" in
    satisfied) EMOJI+="‚úÖ" ;;
    approved) EMOJI+="üü¢" ;;
    rejected) EMOJI+="üî¥" ;;
    comments) EMOJI+="üü°" ;;
    pending) EMOJI+="üîµ" ;;
    *) EMOJI+="üîò" ;;
  esac

  # Mergeable
  case "$MERGEABLE" in
    ready) EMOJI+="‚úÖ" ;;
    conflicts) EMOJI+="‚ùå" ;;
    outdated) EMOJI+="‚ö†Ô∏è" ;;
    *) EMOJI+="üü¢" ;;
  esac

  echo "$EMOJI"
fi
