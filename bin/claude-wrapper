#!/usr/bin/env bash
# claude-wrapper - Process supervisor for interactive Claude CLI
# Usage: claude-wrapper [OPTIONS] [-- COMMAND [ARGS...]]
#
# Options:
#   --no-restart      Exit immediately when child exits (don't offer restart)
#   --auto-restart    Automatically restart on non-zero exit (no prompt)
#   -h, --help        Show this help message
#
# If no command is specified, defaults to running 'claude' (interactive CLI).
# Use '--' to separate wrapper options from command arguments.
#
# Examples:
#   claude-wrapper                    # Run interactive claude
#   claude-wrapper -- claude --model opus   # Run claude with specific model
#   claude-wrapper --auto-restart     # Auto-restart on crash

set -euo pipefail

NO_RESTART="false"
AUTO_RESTART="false"
COMMAND=()

show_help() {
  sed -n '2,16p' "$0" | sed 's/^# //' | sed 's/^#//'
  exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --no-restart)   NO_RESTART="true"; shift ;;
    --auto-restart) AUTO_RESTART="true"; shift ;;
    -h|--help)      show_help ;;
    --)             shift; COMMAND=("$@"); break ;;
    *)              COMMAND=("$@"); break ;;
  esac
done

# Default command is claude
if [[ ${#COMMAND[@]} -eq 0 ]]; then
  COMMAND=("claude")
fi

# Find the actual claude binary (not shell function/alias)
find_claude_binary() {
  # Check common installation locations
  local paths=(
    "/usr/local/bin/claude"
    "/opt/homebrew/bin/claude"
    "$HOME/.local/bin/claude"
    "$HOME/.npm/bin/claude"
    "$HOME/.bun/bin/claude"
  )

  for path in "${paths[@]}"; do
    if [[ -x "$path" ]]; then
      echo "$path"
      return 0
    fi
  done

  # Try 'which' to find it
  local which_path
  which_path=$(which claude 2>/dev/null || true)
  if [[ -n "$which_path" ]] && [[ -x "$which_path" ]]; then
    echo "$which_path"
    return 0
  fi

  # Fallback: use 'command' to bypass aliases/functions
  echo "claude"
}

# If command is just 'claude', use the binary path
if [[ "${COMMAND[0]}" == "claude" ]]; then
  CLAUDE_BIN=$(find_claude_binary)
  COMMAND[0]="$CLAUDE_BIN"
fi

# Track child process
CHILD_PID=""

# Signal handler
cleanup() {
  if [[ -n "$CHILD_PID" ]] && kill -0 "$CHILD_PID" 2>/dev/null; then
    kill -TERM "$CHILD_PID" 2>/dev/null || true
    wait "$CHILD_PID" 2>/dev/null || true
  fi
  exit 130
}

trap cleanup SIGINT SIGTERM

# Main loop
run_child() {
  "${COMMAND[@]}" &
  CHILD_PID=$!
  wait "$CHILD_PID"
  return $?
}

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  Claude Wrapper - Process Supervisor"
echo "  Command: ${COMMAND[*]}"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

while true; do
  # Run the command
  EXIT_CODE=0
  run_child || EXIT_CODE=$?
  CHILD_PID=""

  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo "  Process exited with code: $EXIT_CODE"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  # Handle exit behavior
  if [[ "$NO_RESTART" == "true" ]]; then
    exit "$EXIT_CODE"
  fi

  if [[ "$AUTO_RESTART" == "true" ]] && [[ "$EXIT_CODE" -ne 0 ]]; then
    echo "Auto-restarting in 2 seconds... (Ctrl+C to cancel)"
    sleep 2
    echo ""
    continue
  fi

  # Interactive prompt
  echo ""
  echo "Options:"
  echo "  [r] Restart"
  echo "  [q] Quit"
  echo ""

  # Check if we have gum for nice prompts
  if command -v gum &>/dev/null; then
    CHOICE=$(gum choose "Restart" "Quit" --header "What would you like to do?")
    case "$CHOICE" in
      Restart) continue ;;
      Quit) exit "$EXIT_CODE" ;;
    esac
  else
    # Fallback to basic read
    read -r -p "Choice [r/q]: " CHOICE
    case "$CHOICE" in
      r|R|restart) continue ;;
      q|Q|quit|exit) exit "$EXIT_CODE" ;;
      *) echo "Invalid choice, exiting"; exit "$EXIT_CODE" ;;
    esac
  fi
done
